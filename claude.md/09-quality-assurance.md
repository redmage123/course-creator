# Quality Assurance

## Code Quality and Syntax Validation Requirements (v2.4)

**CRITICAL**: All code generated by Claude Code must pass comprehensive syntax checks and adhere to all directives specified in this CLAUDE.md file. This is a mandatory requirement that cannot be bypassed.

## Mandatory Syntax and Quality Checks

### Pre-Deployment Validation Checklist
Before any code is considered complete, it MUST pass all of the following validation steps:

#### ‚úÖ Python Code Validation
```bash
# 1. Syntax validation
python -m py_compile filename.py

# 2. Import validation (critical for Docker containers)
python -c "import filename; print('Import successful')"

# 3. Code quality checks
flake8 filename.py                    # PEP8 compliance
black --check filename.py             # Formatting validation
isort --check-only filename.py        # Import order validation

# 4. Security scanning
bandit -r filename.py                 # Security vulnerability detection

# 5. Type checking (if type hints used)
mypy filename.py                      # Static type checking
```

#### ‚úÖ JavaScript Code Validation
```bash
# 1. Syntax validation
node -c filename.js                   # Node.js syntax check

# 2. Code quality checks
eslint filename.js                    # ESLint validation
jshint filename.js                    # Alternative syntax checking

# 3. Module import validation
# Verify ES6 imports work correctly in browser environment

# 4. Browser compatibility validation
# Test in Chrome, Firefox, Safari, Edge
```

#### ‚úÖ CSS Code Validation
```bash
# 1. Syntax validation
csslint filename.css                  # CSS syntax validation

# 2. Code quality checks
stylelint filename.css                # Modern CSS linting

# 3. Browser compatibility
# Verify CSS works across target browsers

# 4. Performance validation
# Check for unused CSS and optimization opportunities
```

#### ‚úÖ HTML Code Validation
```bash
# 1. HTML5 validation
html5validator filename.html          # W3C HTML5 validation

# 2. Accessibility validation
axe-core filename.html               # Accessibility compliance

# 3. Cross-browser testing
# Manual verification in target browsers
```

## CLAUDE.md Directive Compliance Verification

Every piece of generated code MUST comply with ALL directives in this CLAUDE.md file:

### ‚úÖ Critical Directive Compliance Checklist

**1. Python Import Requirements (CRITICAL)**
- [ ] **VERIFIED**: All Python imports use absolute imports only
- [ ] **NO RELATIVE IMPORTS**: No `from ..` or `from .` imports anywhere
- [ ] **DOCKER COMPATIBILITY**: All imports work correctly in Docker containers

**2. Exception Handling (CRITICAL)**
- [ ] **CUSTOM EXCEPTIONS**: No generic `except Exception as e` handlers
- [ ] **STRUCTURED ERRORS**: All exception handling uses specific exception types
- [ ] **F-STRING LOGGING**: All error messages use f-string formatting

**3. Documentation Standards (CRITICAL)**
- [ ] **MULTILINE DOCUMENTATION**: All functions/classes have comprehensive documentation
- [ ] **BUSINESS CONTEXT**: Documentation explains why code exists
- [ ] **TECHNICAL RATIONALE**: Documentation explains how code works
- [ ] **FILE-SPECIFIC SYNTAX**: Correct comment syntax for file type

**4. Memory System Usage (CRITICAL)**
- [ ] **CONTEXT STORAGE**: Important information stored in memory system
- [ ] **CONTINUITY**: Previous context recalled appropriately
- [ ] **LEARNING**: System knowledge accumulated over time

### Pre-Commit Validation Script
```bash
#!/bin/bash
# validate-code.sh - Comprehensive code validation pipeline

echo "üîç Starting comprehensive code validation..."

# Python validation
echo "üêç Validating Python code..."
find . -name "*.py" -not -path "./.*" | while read file; do
    echo "Checking $file"
    python -m py_compile "$file" || exit 1
    python -c "import sys; sys.path.append('.'); import $(basename $file .py)" 2>/dev/null || echo "Warning: Import check failed for $file"
    flake8 "$file" || exit 1
    black --check "$file" || exit 1
    isort --check-only "$file" || exit 1
done

# JavaScript validation
echo "üìú Validating JavaScript code..."
find . -name "*.js" -not -path "./node_modules/*" -not -path "./.*" | while read file; do
    echo "Checking $file"
    node -c "$file" || exit 1
    eslint "$file" || exit 1
done

# CSS validation
echo "üé® Validating CSS code..."
find . -name "*.css" -not -path "./node_modules/*" -not -path "./.*" | while read file; do
    echo "Checking $file"
    stylelint "$file" || exit 1
done

echo "‚úÖ All validation checks passed!"
```

## CI/CD Pipeline - GitHub Actions Workflows

The platform uses GitHub Actions workflows for automated testing, code quality analysis, and Docker infrastructure validation.

### **CRITICAL REQUIREMENT: Docker Infrastructure Testing (v3.2.2)**

**MANDATORY**: All code changes, deletions, or additions MUST include Docker infrastructure testing as part of GitHub Actions workflows. This requirement is non-negotiable and applies to every PR and commit.

#### Docker Infrastructure Verification Checklist
Before any code changes are merged, the following MUST be verified:

- [ ] **Container Build Success** - All Docker images build without errors
- [ ] **Container Startup** - All services start successfully
- [ ] **Health Check Passing** - All containers pass health checks within start period
- [ ] **Service Availability** - All services respond to health endpoints (HTTP 200)
- [ ] **HTTPS Configuration** - All services running on HTTPS (not HTTP)
- [ ] **Network Connectivity** - Inter-service communication verified
- [ ] **Database Connectivity** - Services can connect to PostgreSQL/Redis
- [ ] **Volume Mounts** - All required volumes mounted correctly
- [ ] **Environment Variables** - All required env vars present and correct

#### Docker Testing Commands
```bash
# Complete Docker infrastructure verification
./scripts/app-control.sh status                    # Verify all services healthy
./scripts/app-control.sh test-infrastructure       # Run comprehensive infra tests
docker-compose ps                                  # Check all containers running
docker-compose logs --tail=50                      # Review startup logs for errors

# Individual service health checks
curl -k https://localhost:8000/health              # User Management
curl -k https://localhost:8001/health              # Course Management
curl -k https://localhost:8002/health              # Content Generation
curl -k https://localhost:8007/health              # Analytics
curl -k https://localhost:8012/health              # Knowledge Graph
curl -k https://localhost:8013/health              # NLP Preprocessing
# ... (all 16 services)

# Container health verification
docker inspect --format='{{.State.Health.Status}}' course-creator_user-management_1
docker inspect --format='{{.State.Health.Status}}' course-creator_analytics_1
# ... (verify all services show "healthy")
```

#### Pre-Commit Docker Validation Script
```bash
#!/bin/bash
# validate-docker-infrastructure.sh - MANDATORY pre-commit Docker checks

echo "üêã Starting Docker infrastructure validation..."

# Stop and rebuild affected services
echo "üî® Rebuilding Docker services..."
docker-compose build || {
    echo "‚ùå Docker build failed!"
    exit 1
}

# Start all services
echo "üöÄ Starting all services..."
docker-compose up -d || {
    echo "‚ùå Failed to start services!"
    exit 1
}

# Wait for services to initialize
echo "‚è≥ Waiting for services to initialize (60s)..."
sleep 60

# Check container health status
echo "üè• Checking container health..."
UNHEALTHY=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" | wc -l)
STARTING=$(docker ps --filter "health=starting" --format "{{.Names}}" | wc -l)

if [ "$UNHEALTHY" -gt 0 ]; then
    echo "‚ùå Found $UNHEALTHY unhealthy containers:"
    docker ps --filter "health=unhealthy" --format "table {{.Names}}\t{{.Status}}"
    exit 1
fi

if [ "$STARTING" -gt 0 ]; then
    echo "‚è≥ Found $STARTING containers still starting, waiting 30s more..."
    sleep 30
    UNHEALTHY=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" | wc -l)
    if [ "$UNHEALTHY" -gt 0 ]; then
        echo "‚ùå Containers failed to become healthy:"
        docker ps --filter "health=unhealthy" --format "table {{.Names}}\t{{.Status}}"
        exit 1
    fi
fi

# Verify all expected services are running
echo "üîç Verifying all 16 services are running..."
RUNNING=$(docker-compose ps --services --filter "status=running" | wc -l)
if [ "$RUNNING" -lt 16 ]; then
    echo "‚ùå Expected 16 services, but only $RUNNING are running!"
    docker-compose ps
    exit 1
fi

# Test service health endpoints
echo "ü©∫ Testing service health endpoints..."
FAILED_HEALTH_CHECKS=0

for port in 8000 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013; do
    if ! curl -k -f -s -o /dev/null -w "%{http_code}" https://localhost:$port/health | grep -q "200"; then
        echo "‚ùå Health check failed for service on port $port"
        FAILED_HEALTH_CHECKS=$((FAILED_HEALTH_CHECKS + 1))
    fi
done

if [ "$FAILED_HEALTH_CHECKS" -gt 0 ]; then
    echo "‚ùå $FAILED_HEALTH_CHECKS health checks failed!"
    exit 1
fi

echo "‚úÖ All Docker infrastructure checks passed!"
exit 0
```

### GitHub Actions Workflow Configuration

#### Main CI/CD Workflow (`.github/workflows/ci-cd.yml`)
```yaml
name: CI/CD Pipeline with Docker Infrastructure Testing

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install flake8 black isort bandit

      - name: Run code quality checks
        run: |
          ./validate-code.sh

  docker-infrastructure-test:
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Create required directories
        run: |
          mkdir -p ssl logs shared

      - name: Generate self-signed certificates
        run: |
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout ssl/nginx-selfsigned.key \
            -out ssl/nginx-selfsigned.crt \
            -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"

      - name: Create .cc_env file
        run: |
          touch .cc_env
          echo "ENVIRONMENT=ci" >> .cc_env

      - name: Build Docker images
        run: |
          docker-compose build
        timeout-minutes: 30

      - name: Start all services
        run: |
          docker-compose up -d
        timeout-minutes: 5

      - name: Wait for services to initialize
        run: |
          echo "Waiting 90 seconds for all services to start..."
          sleep 90

      - name: Check container health status
        run: |
          echo "Checking Docker container health..."
          docker ps -a

          UNHEALTHY=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" | wc -l)
          if [ "$UNHEALTHY" -gt 0 ]; then
            echo "‚ùå Found unhealthy containers:"
            docker ps --filter "health=unhealthy" --format "table {{.Names}}\t{{.Status}}"
            exit 1
          fi

          echo "‚úÖ All containers are healthy"

      - name: Verify all services running
        run: |
          EXPECTED=16
          RUNNING=$(docker-compose ps --services --filter "status=running" | wc -l)

          if [ "$RUNNING" -lt "$EXPECTED" ]; then
            echo "‚ùå Expected $EXPECTED services, but only $RUNNING are running!"
            docker-compose ps
            exit 1
          fi

          echo "‚úÖ All $EXPECTED services are running"

      - name: Test service health endpoints
        run: |
          FAILED=0

          # Test all service health endpoints
          for port in 8000 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013; do
            echo "Testing service on port $port..."
            STATUS=$(curl -k -s -o /dev/null -w "%{http_code}" https://localhost:$port/health || echo "000")

            if [ "$STATUS" != "200" ]; then
              echo "‚ùå Health check failed for port $port (HTTP $STATUS)"
              FAILED=$((FAILED + 1))
            else
              echo "‚úÖ Service on port $port is healthy"
            fi
          done

          if [ "$FAILED" -gt 0 ]; then
            echo "‚ùå $FAILED health checks failed!"
            docker-compose logs --tail=100
            exit 1
          fi

          echo "‚úÖ All service health checks passed"

      - name: Run app-control.sh status check
        run: |
          chmod +x ./scripts/app-control.sh
          ./scripts/app-control.sh status

      - name: Output logs on failure
        if: failure()
        run: |
          echo "=== Docker Container Status ==="
          docker ps -a

          echo "=== Service Logs ==="
          docker-compose logs --tail=200

          echo "=== Unhealthy Containers ==="
          docker ps --filter "health=unhealthy"

      - name: Cleanup
        if: always()
        run: |
          docker-compose down -v

  unit-tests:
    runs-on: ubuntu-latest
    needs: docker-infrastructure-test
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Run unit tests
        run: |
          python -m pytest tests/unit/ --junitxml=test-results/unit.xml || true

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: test-results/

  security-scan:
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
      - uses: actions/checkout@v3

      - name: Run Bandit security scan
        run: |
          pip install bandit
          bandit -r services/ -f json -o security-report.json || true

      - name: Upload security report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-report
          path: security-report.json
```

#### Branch Protection Rules
Configure the following branch protection rules for `main` and `master` branches:

- ‚úÖ Require status checks to pass before merging
- ‚úÖ Require branches to be up to date before merging
- ‚úÖ Required status checks:
  - `code-quality`
  - `docker-infrastructure-test` (CRITICAL)
  - `unit-tests`
  - `security-scan`
- ‚úÖ Require pull request reviews before merging (minimum 1)
- ‚úÖ Dismiss stale pull request approvals when new commits are pushed

### Workflow Trigger Events
- **Pull Request**: All checks run on PR creation and updates
- **Push to main/master**: Full pipeline runs including infrastructure tests
- **Push to develop**: Full pipeline runs for integration testing
- **Manual**: Can be triggered via GitHub Actions UI for testing

### Monitoring Workflow Results
```bash
# View workflow runs
gh run list --workflow=ci-cd.yml

# View specific run details
gh run view <run-id>

# Download artifacts
gh run download <run-id>

# Re-run failed workflows
gh run rerun <run-id>
```

## Centralized Logging System (v2.2 - Syslog Format)

The platform implements centralized logging with syslog format across all services:

### Syslog Format Implementation
All logs follow RFC 3164 syslog format:
```
Jul 31 08:46:30 hostname service[pid]: LEVEL - filename:line - message
```

Example log entries:
```
Jul 31 08:46:30 20b86b2e3329 course-generator[1]: INFO - /app/main.py:71 - Starting Course Generator Service
Jul 31 08:46:29 6dd7386d44f5 user-management[1]: INFO - /app/main.py:497 - Starting User Management Service on port 8000
```

### Log File Locations
- **Docker Environment**: `/var/log/course-creator/<service>.log` (mounted volume)
- **Development Environment**: `./logs/course-creator/<service>.log`
- **Console Output**: All services also output to stdout with syslog format

### Log File Management
- **Rotation**: 50MB max file size, 10 backup files
- **Levels**: DEBUG (file only), INFO+ (console and file)
- **Services Logged**: All microservices, uvicorn, FastAPI
- **Format**: Includes hostname, PID, service name, log level, file location, and message

### Monitoring Log Files
```bash
# View all service logs in syslog format
docker compose logs -f

# View specific service logs
docker compose logs -f user-management

# Monitor log files directly
tail -f ./logs/course-creator/*.log

# Check log file sizes and rotation
ls -lh ./logs/course-creator/
```

## Code Review Process

### Pull Request Requirements
- [ ] **Docker infrastructure tests pass** - ALL containers healthy, all services respond (CRITICAL)
- [ ] **All tests pass** - Unit, integration, and E2E tests
- [ ] **Code coverage maintained** - Minimum 80% coverage
- [ ] **Security scan passed** - No new vulnerabilities
- [ ] **CLAUDE.md compliance verified** - All directives followed
- [ ] **Documentation updated** - README and API docs current
- [ ] **Manual testing completed** - Feature tested locally with Docker
- [ ] **Health checks verified** - All 16 services passing health checks
- [ ] **HTTPS configuration** - All services running on HTTPS (not HTTP)

### Code Review Checklist
- [ ] **Architecture consistency** - Follows established patterns
- [ ] **Performance considerations** - No obvious performance issues
- [ ] **Security review** - No security vulnerabilities introduced
- [ ] **Error handling** - Proper exception handling implemented
- [ ] **Logging** - Appropriate logging levels and messages
- [ ] **Configuration** - Environment-specific configs handled properly

## Compliance and Audit

### Automated Compliance Checks
- **Daily Validation** - Automated validation runs on all changed files
- **Pre-commit Hooks** - Validation integrated into git workflow
- **CI/CD Integration** - Validation gates in deployment pipeline
- **Code Review Requirements** - Manual verification of CLAUDE.md compliance
- **Documentation Audits** - Regular reviews of documentation completeness

### Security Compliance
- **OWASP Top 10** - Regular security assessments
- **Dependency Scanning** - Automated vulnerability scanning of dependencies
- **Secret Detection** - Git hooks prevent secret commits
- **Access Control** - Role-based access to production systems
- **Audit Logging** - All administrative actions logged and monitored

### Performance Monitoring
- **Application Performance Monitoring (APM)** - Real-time performance tracking
- **Database Performance** - Query performance and optimization monitoring
- **Infrastructure Monitoring** - CPU, memory, disk, and network monitoring
- **User Experience Monitoring** - Frontend performance and error tracking

### Quality Metrics Dashboard
- **Code Coverage Trends** - Track coverage over time
- **Bug Density** - Bugs per lines of code
- **Technical Debt** - SonarQube technical debt tracking
- **Test Success Rate** - Percentage of passing tests over time
- **Deployment Frequency** - How often deployments occur
- **Mean Time to Recovery (MTTR)** - Average time to fix issues

## Continuous Improvement

### Quality Improvement Process
1. **Identify Issues** - Through monitoring, testing, and user feedback
2. **Root Cause Analysis** - Determine underlying causes
3. **Implement Fixes** - Address root causes, not just symptoms
4. **Validate Improvements** - Measure effectiveness of changes
5. **Update Processes** - Improve development and quality processes
6. **Share Learnings** - Document and share lessons learned

### Regular Quality Reviews
- **Weekly**: Code quality metrics review
- **Monthly**: Security scan results and remediation
- **Quarterly**: Architecture and technical debt assessment
- **Annually**: Comprehensive quality process review and improvement

This validation system ensures that all code maintains the high quality standards established in this repository and prevents regressions in critical areas like session management, documentation quality, and architectural compliance.