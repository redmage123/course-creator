#!/usr/bin/env python3
"""
Software Engineer Agent for Course Creator

This agent acts as a senior software engineer that can generate complete microservices
with all necessary files including code, configuration, tests, and documentation.
"""

import os
import sys
import json
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import textwrap

# Add the shared directory to the path so we can import our models
sys.path.append(str(Path(__file__).parent.parent.parent / "shared"))

@dataclass
class ServiceSpec:
    """Specification for a microservice to be generated"""
    name: str
    description: str
    port: int
    endpoints: List[Dict[str, Any]]
    dependencies: List[str]
    database_models: List[Dict[str, Any]]
    async_tasks: List[Dict[str, Any]]
    websocket_endpoints: List[Dict[str, Any]]
    middleware: List[str]

class SoftwareEngineerAgent:
    """
    AI-powered software engineer agent that generates complete microservices
    """
    
    def __init__(self):
        self.repo_root = Path(__file__).parent.parent.parent
        self.services_dir = self.repo_root / "services"
        self.shared_dir = self.repo_root / "shared"
        self.config_dir = self.repo_root / "config"
        
    def generate_service(self, spec: ServiceSpec) -> bool:
        """Generate a complete microservice based on the specification"""
        
        print(f"🏗️  Generating microservice: {spec.name}")
        
        service_dir = self.services_dir / spec.name
        service_dir.mkdir(exist_ok=True)
        
        # Generate all service components
        self._generate_main_app(service_dir, spec)
        self._generate_models(service_dir, spec)
        self._generate_routers(service_dir, spec)
        self._generate_services(service_dir, spec)
        self._generate_dependencies(service_dir, spec)
        self._generate_middleware(service_dir, spec)
        self._generate_dockerfile(service_dir, spec)
        self._generate_requirements(service_dir, spec)
        self._generate_tests(service_dir, spec)
        self._generate_config(spec)
        self._generate_docker_compose_update(spec)
        
        print(f"✅ Successfully generated microservice: {spec.name}")
        return True
    
    def _generate_main_app(self, service_dir: Path, spec: ServiceSpec):
        """Generate the main FastAPI application"""
        
        router_imports = ", ".join([f"{endpoint['name']}_router" for endpoint in spec.endpoints])
        middleware_imports = ", ".join([f"{mw}_middleware" for mw in spec.middleware])
        middleware_additions = "\n".join([f"app.add_middleware({mw}_middleware)" for mw in spec.middleware])
        router_inclusions = "\n".join([f'app.include_router({endpoint["name"]}_router, prefix="/{endpoint["name"]}", tags=["{endpoint["name"]}"])' for endpoint in spec.endpoints])
        
        main_content = f'''"""
{spec.description}

This microservice is part of the Course Creator platform.
Generated by Software Engineer Agent on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
"""

import logging
from contextlib import asynccontextmanager
from typing import Dict, Any

from fastapi import FastAPI, HTTPException, Depends
from starlette.middleware.cors import CORSMiddleware
from starlette.middleware.trustedhost import TrustedHostMiddleware
import uvicorn

from ...shared.utils.config_manager import config_manager
from ...shared.utils.logging import setup_logging
from .routers import {router_imports}
from .dependencies import get_database, get_redis
from .middleware import {middleware_imports}

# Setup logging
logger = setup_logging()

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan management"""
    logger.info(f"Starting {spec.name} service on port {spec.port}")
    yield
    logger.info(f"Shutting down {spec.name} service")

# Create FastAPI application
app = FastAPI(
    title="{spec.description}",
    description="{spec.description} for the Course Creator platform",
    version="1.0.0",
    lifespan=lifespan
)

# Get service configuration
config = config_manager.get_service_config("{spec.name.replace('-', '_')}")

# Add middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=config.get("cors_origins", ["*"]),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=config.get("allowed_hosts", ["*"])
)

# Add custom middleware
{middleware_additions}

# Include routers
{router_inclusions}

@app.get("/health")
async def health_check() -> Dict[str, Any]:
    """Health check endpoint"""
    return {{
        "status": "healthy",
        "service": "{spec.name}",
        "version": "1.0.0",
        "timestamp": "{datetime.now().isoformat()}"
    }}

@app.get("/")
async def root() -> Dict[str, str]:
    """Root endpoint"""
    return {{
        "message": "{spec.description}",
        "service": "{spec.name}",
        "version": "1.0.0"
    }}

if __name__ == "__main__":
    uvicorn.run(
        app,
        host=config.get("host", "0.0.0.0"),
        port=config.get("port", {spec.port}),
        workers=config.get("workers", 1)
    )
'''
        
        (service_dir / "main.py").write_text(main_content)
        (service_dir / "__init__.py").write_text("")
    
    def _generate_models(self, service_dir: Path, spec: ServiceSpec):
        """Generate Pydantic models"""
        
        models_dir = service_dir / "models"
        models_dir.mkdir(exist_ok=True)
        
        # Generate __init__.py
        model_imports = []
        for model in spec.database_models:
            model_imports.append(f"from .{model['name'].lower()} import {model['name']}")
        
        init_content = f'''"""
Database models for {spec.name} service
"""

{chr(10).join(model_imports)}

__all__ = {[model['name'] for model in spec.database_models]}
'''
        
        (models_dir / "__init__.py").write_text(init_content)
        
        # Generate individual model files
        for model in spec.database_models:
            model_content = self._generate_model_file(model)
            (models_dir / f"{model['name'].lower()}.py").write_text(model_content)
    
    def _generate_model_file(self, model: Dict[str, Any]) -> str:
        """Generate a single model file"""
        
        fields_code = []
        for field in model['fields']:
            field_type = field['type']
            field_name = field['name']
            default = field.get('default', 'None')
            nullable = field.get('nullable', False)
            
            if nullable:
                field_type = f"Optional[{field_type}]"
            
            if default == 'None' and not nullable:
                fields_code.append(f"    {field_name}: {field_type}")
            else:
                fields_code.append(f"    {field_name}: {field_type} = {default}")
        
        return f'''"""
{model['name']} model for {model.get('description', 'database operations')}
"""

from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, Field
import uuid

class {model['name']}Base(BaseModel):
    """Base {model['name']} model"""
{chr(10).join(fields_code)}

class {model['name']}Create({model['name']}Base):
    """Create {model['name']} model"""
    pass

class {model['name']}Update(BaseModel):
    """Update {model['name']} model"""
{chr(10).join([f"    {field['name']}: Optional[{field['type']}] = None" for field in model['fields'] if field['name'] != 'id'])}

class {model['name']}({model['name']}Base):
    """Full {model['name']} model"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    
    class Config:
        from_attributes = True
'''
    
    def _generate_routers(self, service_dir: Path, spec: ServiceSpec):
        """Generate FastAPI routers"""
        
        routers_dir = service_dir / "routers"
        routers_dir.mkdir(exist_ok=True)
        
        # Generate __init__.py
        router_imports = []
        for endpoint in spec.endpoints:
            router_imports.append(f"from .{endpoint['name']} import router as {endpoint['name']}_router")
        
        init_content = f'''"""
API routers for {spec.name} service
"""

{chr(10).join(router_imports)}

__all__ = {[f"{endpoint['name']}_router" for endpoint in spec.endpoints]}
'''
        
        (routers_dir / "__init__.py").write_text(init_content)
        
        # Generate individual router files
        for endpoint in spec.endpoints:
            router_content = self._generate_router_file(endpoint, spec)
            (routers_dir / f"{endpoint['name']}.py").write_text(router_content)
    
    def _generate_router_file(self, endpoint: Dict[str, Any], spec: ServiceSpec) -> str:
        """Generate a single router file"""
        
        routes_code = []
        for route in endpoint.get('routes', []):
            method = route['method'].lower()
            path = route['path']
            func_name = route['function_name']
            description = route.get('description', f'{method.upper()} {path}')
            
            # Generate route parameters
            params = []
            if route.get('path_params'):
                for param in route['path_params']:
                    params.append(f"{param['name']}: {param['type']}")
            
            if route.get('query_params'):
                for param in route['query_params']:
                    default = f" = {param['default']}" if 'default' in param else ""
                    params.append(f"{param['name']}: {param['type']}{default}")
            
            if route.get('body_param'):
                body = route['body_param']
                params.append(f"{body['name']}: {body['type']}")
            
            params_str = ", ".join(params)
            if params_str:
                params_str = ", " + params_str
            
            routes_code.append(f'''
@router.{method}("{path}")
async def {func_name}({params_str}) -> {route.get('return_type', 'Dict[str, Any]')}:
    """
    {description}
    """
    # TODO: Implement {func_name}
    return {{"message": "Not implemented yet"}}
''')
        
        return f'''"""
{endpoint['name'].title()} router for {spec.name} service
"""

from typing import Dict, Any, List, Optional
from fastapi import APIRouter, HTTPException, Depends, status
from ..models import *
from ..services.{endpoint['name']}_service import {endpoint['name'].title()}Service
from ..dependencies import get_database

router = APIRouter()

{chr(10).join(routes_code)}
'''
    
    def _generate_services(self, service_dir: Path, spec: ServiceSpec):
        """Generate service layer classes"""
        
        services_dir = service_dir / "services"
        services_dir.mkdir(exist_ok=True)
        
        # Generate __init__.py
        (services_dir / "__init__.py").write_text('"""Service layer for business logic"""')
        
        # Generate service files for each endpoint
        for endpoint in spec.endpoints:
            service_content = f'''"""
{endpoint['name'].title()} service for business logic
"""

from typing import List, Optional, Dict, Any
from ..models import *

class {endpoint['name'].title()}Service:
    """Service class for {endpoint['name']} operations"""
    
    def __init__(self, db_session):
        self.db = db_session
    
    async def create_{endpoint['name']}(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new {endpoint['name']}"""
        # TODO: Implement create logic
        return {{"message": "Created {endpoint['name']}"}}
    
    async def get_{endpoint['name']}(self, id: str) -> Optional[Dict[str, Any]]:
        """Get {endpoint['name']} by ID"""
        # TODO: Implement get logic
        return None
    
    async def update_{endpoint['name']}(self, id: str, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Update {endpoint['name']}"""
        # TODO: Implement update logic
        return None
    
    async def delete_{endpoint['name']}(self, id: str) -> bool:
        """Delete {endpoint['name']}"""
        # TODO: Implement delete logic
        return False
    
    async def list_{endpoint['name']}s(self, limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
        """List {endpoint['name']}s with pagination"""
        # TODO: Implement list logic
        return []
'''
            
            (services_dir / f"{endpoint['name']}_service.py").write_text(service_content)
    
    def _generate_dependencies(self, service_dir: Path, spec: ServiceSpec):
        """Generate FastAPI dependencies"""
        
        deps_content = f'''"""
FastAPI dependencies for {spec.name} service
"""

import asyncio
from typing import AsyncGenerator
from fastapi import Depends
import asyncpg
import aioredis
from ...shared.utils.config_manager import config_manager

# Database dependency
async def get_database() -> AsyncGenerator[asyncpg.Connection, None]:
    """Get database connection"""
    config = config_manager.get_database_config()
    
    conn = await asyncpg.connect(
        host=config.host,
        port=config.port,
        user=config.user,
        password=config.password,
        database=config.name
    )
    
    try:
        yield conn
    finally:
        await conn.close()

# Redis dependency
async def get_redis() -> AsyncGenerator[aioredis.Redis, None]:
    """Get Redis connection"""
    config = config_manager.get_messaging_config()
    
    redis = aioredis.from_url(
        f"redis://{{config.host}}:{{config.port}}",
        password=config.password,
        db=config.db
    )
    
    try:
        yield redis
    finally:
        await redis.close()
'''
        
        (service_dir / "dependencies.py").write_text(deps_content)
    
    def _generate_middleware(self, service_dir: Path, spec: ServiceSpec):
        """Generate custom middleware"""
        
        middleware_dir = service_dir / "middleware"
        middleware_dir.mkdir(exist_ok=True)
        
        (middleware_dir / "__init__.py").write_text("")
        
        for mw in spec.middleware:
            mw_content = f'''"""
{mw.title()} middleware for {spec.name} service
"""

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
import time
import logging

logger = logging.getLogger(__name__)

class {mw.title()}Middleware(BaseHTTPMiddleware):
    """Custom {mw} middleware"""
    
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        
        # Pre-processing
        logger.info(f"Processing request: {{request.method}} {{request.url}}")
        
        # Process request
        response = await call_next(request)
        
        # Post-processing
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        
        logger.info(f"Request processed in {{process_time:.4f}}s")
        
        return response

# Middleware instance
{mw}_middleware = {mw.title()}Middleware
'''
            
            (middleware_dir / f"{mw}.py").write_text(mw_content)
    
    def _generate_dockerfile(self, service_dir: Path, spec: ServiceSpec):
        """Generate Dockerfile for the service"""
        
        dockerfile_content = f'''FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
COPY {spec.name}/requirements.txt ./service_requirements.txt
RUN pip install --no-cache-dir -r requirements.txt -r service_requirements.txt

# Copy application code
COPY shared/ ./shared/
COPY services/{spec.name}/ ./
COPY config/ ./config/

# Create non-root user
RUN adduser --disabled-password --gecos '' appuser
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE {spec.port}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{spec.port}/health || exit 1

# Run application
CMD ["python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "{spec.port}"]
'''
        
        (service_dir / "Dockerfile").write_text(dockerfile_content)
    
    def _generate_requirements(self, service_dir: Path, spec: ServiceSpec):
        """Generate requirements.txt for the service"""
        
        base_requirements = [
            "fastapi>=0.104.0",
            "uvicorn[standard]>=0.24.0",
            "pydantic>=2.5.0",
            "asyncpg>=0.29.0",
            "aioredis>=2.0.1",
            "httpx>=0.25.0",
        ]
        
        # Add service-specific dependencies
        requirements = base_requirements + spec.dependencies
        
        (service_dir / "requirements.txt").write_text("\n".join(requirements))
    
    def _generate_tests(self, service_dir: Path, spec: ServiceSpec):
        """Generate comprehensive test suite"""
        
        tests_dir = service_dir / "tests"
        tests_dir.mkdir(exist_ok=True)
        
        # Test configuration
        (tests_dir / "__init__.py").write_text("")
        (tests_dir / "conftest.py").write_text(self._generate_test_config(spec))
        
        # Unit tests
        (tests_dir / "test_main.py").write_text(self._generate_main_tests(spec))
        
        # Router tests
        for endpoint in spec.endpoints:
            test_content = self._generate_router_tests(endpoint, spec)
            (tests_dir / f"test_{endpoint['name']}_router.py").write_text(test_content)
        
        # Service tests
        for endpoint in spec.endpoints:
            test_content = self._generate_service_tests(endpoint, spec)
            (tests_dir / f"test_{endpoint['name']}_service.py").write_text(test_content)
        
        # Integration tests
        (tests_dir / "test_integration.py").write_text(self._generate_integration_tests(spec))
    
    def _generate_test_config(self, spec: ServiceSpec) -> str:
        """Generate pytest configuration"""
        
        return f'''"""
Test configuration for {spec.name} service
"""

import pytest
import asyncio
from fastapi.testclient import TestClient
from httpx import AsyncClient
from unittest.mock import AsyncMock, MagicMock

from main import app

@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def client():
    """Create test client"""
    return TestClient(app)

@pytest.fixture
async def async_client():
    """Create async test client"""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

@pytest.fixture
def mock_database():
    """Mock database connection"""
    return AsyncMock()

@pytest.fixture
def mock_redis():
    """Mock Redis connection"""
    return AsyncMock()
'''
    
    def _generate_main_tests(self, spec: ServiceSpec) -> str:
        """Generate tests for main application"""
        
        return f'''"""
Tests for main application of {spec.name} service
"""

import pytest
from fastapi.testclient import TestClient

def test_health_check(client):
    """Test health check endpoint"""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
    assert data["service"] == "{spec.name}"

def test_root_endpoint(client):
    """Test root endpoint"""
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert data["service"] == "{spec.name}"
    assert "message" in data

@pytest.mark.asyncio
async def test_async_health_check(async_client):
    """Test health check with async client"""
    response = await async_client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
'''
    
    def _generate_router_tests(self, endpoint: Dict[str, Any], spec: ServiceSpec) -> str:
        """Generate tests for router endpoints"""
        
        return f'''"""
Tests for {endpoint['name']} router of {spec.name} service
"""

import pytest
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_{endpoint['name']}_endpoints(async_client, mock_database):
    """Test {endpoint['name']} endpoints"""
    
    # Test endpoint accessibility
    with patch('dependencies.get_database', return_value=mock_database):
        response = await async_client.get("/{endpoint['name']}/")
        # Adjust assertion based on expected behavior
        assert response.status_code in [200, 404, 405]  # Depending on implementation

# TODO: Add specific tests for each route in the endpoint
'''
    
    def _generate_service_tests(self, endpoint: Dict[str, Any], spec: ServiceSpec) -> str:
        """Generate tests for service classes"""
        
        return f'''"""
Tests for {endpoint['name']} service of {spec.name}
"""

import pytest
from unittest.mock import AsyncMock
from services.{endpoint['name']}_service import {endpoint['name'].title()}Service

@pytest.mark.asyncio
async def test_{endpoint['name']}_service_creation():
    """Test service creation"""
    mock_db = AsyncMock()
    service = {endpoint['name'].title()}Service(mock_db)
    assert service.db == mock_db

@pytest.mark.asyncio
async def test_create_{endpoint['name']}():
    """Test create {endpoint['name']} method"""
    mock_db = AsyncMock()
    service = {endpoint['name'].title()}Service(mock_db)
    
    data = {{"test": "data"}}
    result = await service.create_{endpoint['name']}(data)
    
    assert result is not None
    assert "message" in result

@pytest.mark.asyncio
async def test_get_{endpoint['name']}():
    """Test get {endpoint['name']} method"""
    mock_db = AsyncMock()
    service = {endpoint['name'].title()}Service(mock_db)
    
    result = await service.get_{endpoint['name']}("test-id")
    # This will be None until implemented
    assert result is None

@pytest.mark.asyncio
async def test_list_{endpoint['name']}s():
    """Test list {endpoint['name']}s method"""
    mock_db = AsyncMock()
    service = {endpoint['name'].title()}Service(mock_db)
    
    result = await service.list_{endpoint['name']}s()
    assert isinstance(result, list)
'''
    
    def _generate_integration_tests(self, spec: ServiceSpec) -> str:
        """Generate integration tests"""
        
        endpoints_list = ', '.join([f'"/{endpoint["name"]}/"' for endpoint in spec.endpoints])
        
        return f'''"""
Integration tests for {spec.name} service
"""

import pytest
import asyncio
from httpx import AsyncClient

@pytest.mark.integration
@pytest.mark.asyncio
async def test_service_integration(async_client):
    """Test full service integration"""
    
    # Test health check
    response = await async_client.get("/health")
    assert response.status_code == 200
    
    # Test service is responsive
    data = response.json()
    assert data["status"] == "healthy"

@pytest.mark.integration
async def test_endpoints_integration(async_client):
    """Test all endpoints are accessible"""
    
    endpoints = [{endpoints_list}]
    
    for endpoint in endpoints:
        response = await async_client.get(endpoint)
        # Should not return 500 (server error)
        assert response.status_code < 500
'''
    
    def _generate_config(self, spec: ServiceSpec):
        """Update service configuration"""
        
        service_config_path = self.config_dir / "services" / f"{spec.name.replace('-', '_')}.yaml"
        service_config_path.parent.mkdir(exist_ok=True)
        
        config_content = f'''# Configuration for {spec.name} service
{spec.name.replace('-', '_')}:
  host: "0.0.0.0"
  port: {spec.port}
  workers: 1
  timeout: 300
  cors_origins:
    - "http://localhost:3000"
    - "http://localhost:8000"
  allowed_hosts:
    - "*"
  
  # Service-specific configuration
  description: "{spec.description}"
  endpoints: {[endpoint['name'] for endpoint in spec.endpoints]}
  
  # Database settings
  database:
    pool_size: 10
    max_overflow: 20
    echo: false
  
  # Cache settings
  cache:
    ttl: 3600
    max_size: 1000
'''
        
        service_config_path.write_text(config_content)
    
    def _generate_docker_compose_update(self, spec: ServiceSpec):
        """Generate docker-compose service definition"""
        
        compose_fragment = f'''
  {spec.name}:
    build:
      context: .
      dockerfile: services/{spec.name}/Dockerfile
    ports:
      - "${{{spec.name.upper().replace('-', '_')}_PORT:-{spec.port}}}:{spec.port}"
    environment:
      - ENVIRONMENT=${{ENVIRONMENT:-development}}
      - ANTHROPIC_API_KEY=${{ANTHROPIC_API_KEY}}
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./config:/app/config
      - ./shared:/app/shared
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{spec.port}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
'''
        
        # Write to a separate file that can be manually added to docker-compose.yml
        compose_file = self.repo_root / f"docker-compose.{spec.name}.yml"
        compose_file.write_text(f"# Add this to your main docker-compose.yml:{compose_fragment}")
        
        print(f"📝 Docker compose fragment written to: {compose_file}")
        print(f"   Add the content to your main docker-compose.yml file")

def main():
    """Main CLI interface for the Software Engineer Agent"""
    
    parser = argparse.ArgumentParser(description="Software Engineer Agent - Generate microservices")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Generate service command
    gen_parser = subparsers.add_parser('generate', help='Generate a new microservice')
    gen_parser.add_argument('--spec', '-s', required=True, help='Path to service specification JSON file')
    gen_parser.add_argument('--interactive', '-i', action='store_true', help='Interactive mode')
    
    # List templates command
    list_parser = subparsers.add_parser('templates', help='List available service templates')
    
    args = parser.parse_args()
    
    agent = SoftwareEngineerAgent()
    
    if args.command == 'generate':
        if args.interactive:
            spec = interactive_spec_builder()
        else:
            with open(args.spec, 'r') as f:
                spec_data = json.load(f)
                spec = ServiceSpec(**spec_data)
        
        agent.generate_service(spec)
    
    elif args.command == 'templates':
        show_templates()
    
    else:
        parser.print_help()

def interactive_spec_builder() -> ServiceSpec:
    """Interactive specification builder"""
    
    print("🤖 Software Engineer Agent - Interactive Service Builder")
    print("=" * 60)
    
    # Basic service info
    name = input("Service name (e.g., 'content-analyzer'): ").strip()
    description = input("Service description: ").strip()
    port = int(input("Service port (e.g., 8006): ").strip())
    
    # Endpoints
    endpoints = []
    print("\n📍 Define API endpoints:")
    while True:
        endpoint_name = input("Endpoint name (or 'done' to finish): ").strip()
        if endpoint_name.lower() == 'done':
            break
        
        endpoint = {
            "name": endpoint_name,
            "routes": [
                {
                    "method": "GET",
                    "path": f"/{endpoint_name}s",
                    "function_name": f"list_{endpoint_name}s",
                    "description": f"List {endpoint_name}s",
                    "return_type": "List[Dict[str, Any]]"
                },
                {
                    "method": "POST",
                    "path": f"/{endpoint_name}s",
                    "function_name": f"create_{endpoint_name}",
                    "description": f"Create {endpoint_name}",
                    "return_type": "Dict[str, Any]",
                    "body_param": {"name": "data", "type": "Dict[str, Any]"}
                },
                {
                    "method": "GET",
                    "path": f"/{endpoint_name}s/{{id}}",
                    "function_name": f"get_{endpoint_name}",
                    "description": f"Get {endpoint_name} by ID",
                    "return_type": "Dict[str, Any]",
                    "path_params": [{"name": "id", "type": "str"}]
                }
            ]
        }
        endpoints.append(endpoint)
    
    # Database models
    models = []
    print("\n🗄️  Define database models:")
    for endpoint in endpoints:
        model_name = endpoint['name'].title()
        model = {
            "name": model_name,
            "description": f"{model_name} database model",
            "fields": [
                {"name": "name", "type": "str", "nullable": False},
                {"name": "description", "type": "str", "nullable": True, "default": "None"},
                {"name": "is_active", "type": "bool", "default": "True"}
            ]
        }
        models.append(model)
    
    # Dependencies
    print("\n📦 Additional Python dependencies (comma-separated, or press Enter for none):")
    deps_input = input("Dependencies: ").strip()
    dependencies = [dep.strip() for dep in deps_input.split(',')] if deps_input else []
    
    return ServiceSpec(
        name=name,
        description=description,
        port=port,
        endpoints=endpoints,
        dependencies=dependencies,
        database_models=models,
        async_tasks=[],
        websocket_endpoints=[],
        middleware=["logging", "timing"]
    )

def show_templates():
    """Show available service templates"""
    
    # Get the current agent instance to access the repo structure
    agent = SoftwareEngineerAgent()
    templates_dir = Path(__file__).parent / "templates"
    
    print("🎨 Available Service Templates:")
    print("=" * 40)
    
    if not templates_dir.exists():
        print("No templates directory found. Create templates/ and add JSON files.")
        return
    
    # Find all JSON files in templates directory
    template_files = list(templates_dir.glob("*.json"))
    
    if not template_files:
        print("No template files found in templates/ directory.")
        print("Create JSON template files like 'my-service.json'")
        return
    
    # Read and display each template
    for template_file in sorted(template_files):
        try:
            with open(template_file, 'r') as f:
                template_data = json.load(f)
                
            template_name = template_file.stem
            description = template_data.get('description', 'No description available')
            port = template_data.get('port', 'Unknown')
            endpoint_count = len(template_data.get('endpoints', []))
            
            print(f"  {template_name:20} - {description}")
            print(f"    {'':20}   Port: {port}, Endpoints: {endpoint_count}")
            
        except (json.JSONDecodeError, KeyError, FileNotFoundError) as e:
            print(f"  {template_file.stem:20} - ERROR: Invalid template file ({e})")
    
    print(f"\nFound {len(template_files)} template(s)")
    print("To use a template: python software_engineer_agent.py generate --spec templates/TEMPLATE_NAME.json")
if __name__ == "__main__":
    main()
