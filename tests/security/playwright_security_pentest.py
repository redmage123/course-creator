#!/usr/bin/env python3
"""
Security Penetration Testing Script for Course Creator Platform

AUTHORIZED SECURITY TESTING ONLY
This script simulates various attack vectors to identify vulnerabilities.
Run only on systems you own or have explicit permission to test.

Tests include:
1. Authentication attacks (brute force, credential stuffing, SQL injection)
2. Authorization bypasses (privilege escalation, IDOR)
3. Input validation attacks (XSS, command injection, path traversal)
4. Session management attacks (session fixation, hijacking)
5. API security (rate limiting, authentication bypass, data exposure)
6. OWASP Top 10 vulnerability checks
"""

import os
import sys
import json
import asyncio
import logging
import random
import string
import time
import re
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple
from urllib.parse import urljoin, quote, urlencode

from playwright.async_api import async_playwright, Browser, Page, BrowserContext, Response

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configuration
BASE_URL = os.getenv('TEST_BASE_URL', 'https://localhost:3000')
API_BASE_URL = os.getenv('API_BASE_URL', 'https://localhost:8000')
OUTPUT_DIR = Path('tests/reports/security_pentest')
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# Test credentials
VALID_CREDENTIALS = {
    'admin': {'email': 'admin@example.com', 'password': 'password123'},
    'org_admin': {'email': 'orgadmin@example.com', 'password': 'password123'},
    'instructor': {'email': 'instructor@example.com', 'password': 'password123'},
    'student': {'email': 'student@example.com', 'password': 'password123'},
}

@dataclass
class SecurityFinding:
    """Represents a security vulnerability finding"""
    severity: str  # critical, high, medium, low, info
    category: str
    title: str
    description: str
    evidence: str
    recommendation: str
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None

@dataclass
class TestResult:
    """Represents a security test result"""
    test_name: str
    category: str
    passed: bool
    duration_ms: int
    details: Dict[str, Any]
    findings: List[SecurityFinding] = field(default_factory=list)


class SecurityPenTester:
    """
    Comprehensive security penetration tester for Course Creator Platform

    Simulates various attack vectors to identify vulnerabilities
    """

    def __init__(self):
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.results: List[TestResult] = []
        self.findings: List[SecurityFinding] = []
        self.test_run_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))

    async def setup(self):
        """Initialize browser for testing"""
        playwright = await async_playwright().start()
        self.browser = await playwright.chromium.launch(
            headless=os.getenv('HEADLESS', 'true').lower() == 'true',
            args=['--ignore-certificate-errors', '--disable-web-security']
        )
        self.context = await self.browser.new_context(
            ignore_https_errors=True,
            viewport={'width': 1920, 'height': 1080}
        )
        self.page = await self.context.new_page()
        logger.info(f"Security test initialized - Run ID: {self.test_run_id}")

    async def teardown(self):
        """Cleanup browser resources"""
        if self.browser:
            await self.browser.close()

    async def run_test(self, name: str, category: str, test_func) -> TestResult:
        """Execute a security test and record results"""
        start_time = time.time()
        details = {}
        findings = []
        passed = True

        try:
            logger.info(f"Running: {name} ({category})")
            result = await test_func()
            if isinstance(result, tuple):
                details, findings = result
            else:
                details = result or {}

            # Check if any critical/high findings
            if any(f.severity in ['critical', 'high'] for f in findings):
                passed = False

        except Exception as e:
            logger.error(f"Test error {name}: {e}")
            details = {'error': str(e)}
            passed = False

        duration = int((time.time() - start_time) * 1000)

        result = TestResult(
            test_name=name,
            category=category,
            passed=passed,
            duration_ms=duration,
            details=details,
            findings=findings
        )

        self.results.append(result)
        self.findings.extend(findings)

        status = "âœ… SECURE" if passed else "ðŸ”´ VULNERABLE"
        logger.info(f"{status}: {name} ({len(findings)} findings)")

        return result

    # =========================================================================
    # AUTHENTICATION ATTACKS
    # =========================================================================

    async def test_sql_injection_login(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for SQL injection in login form"""
        findings = []
        details = {'payloads_tested': 0, 'vulnerable': False}

        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "' UNION SELECT * FROM users--",
            "1' OR '1' = '1",
            "' OR 1=1--",
            "' OR 'x'='x",
            "'; DROP TABLE users;--",
            "' AND 1=1--",
            "' AND '1'='1",
            "admin' AND '1'='1",
            "' OR ''='",
            "' OR 1 --",
            "' OR 'a'='a",
        ]

        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')

        for payload in sql_payloads:
            details['payloads_tested'] += 1

            try:
                # Clear and fill form with SQL injection payload
                await self.page.fill('input[type="email"], input[name="email"], #email', payload)
                await self.page.fill('input[type="password"], input[name="password"], #password', 'anything')

                # Intercept response
                response_data = []
                async def capture_response(response):
                    if 'login' in response.url or 'auth' in response.url:
                        response_data.append({
                            'status': response.status,
                            'url': response.url
                        })

                self.page.on('response', capture_response)

                # Submit form
                await self.page.click('button[type="submit"]')
                await self.page.wait_for_timeout(1000)

                # Check for successful bypass indicators
                current_url = self.page.url
                page_content = await self.page.content()

                # Check for SQL error messages (information disclosure)
                sql_errors = [
                    'sql syntax', 'mysql', 'postgresql', 'sqlite',
                    'ora-', 'db2', 'odbc', 'jdbc',
                    'syntax error', 'unclosed quotation'
                ]

                for error in sql_errors:
                    if error.lower() in page_content.lower():
                        details['vulnerable'] = True
                        findings.append(SecurityFinding(
                            severity='critical',
                            category='SQL Injection',
                            title='SQL Error Disclosure in Login',
                            description=f'SQL error message exposed with payload: {payload}',
                            evidence=f'Error pattern "{error}" found in response',
                            recommendation='Implement parameterized queries and hide detailed error messages',
                            cwe_id='CWE-89',
                            owasp_category='A03:2021-Injection'
                        ))

                # Check if we bypassed login
                if '/dashboard' in current_url or 'authenticated' in page_content.lower():
                    details['vulnerable'] = True
                    findings.append(SecurityFinding(
                        severity='critical',
                        category='SQL Injection',
                        title='Authentication Bypass via SQL Injection',
                        description=f'Login bypassed with payload: {payload}',
                        evidence=f'Redirected to {current_url} after injection',
                        recommendation='Use parameterized queries/prepared statements',
                        cwe_id='CWE-89',
                        owasp_category='A03:2021-Injection'
                    ))

                # Reset for next test
                await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')

            except Exception as e:
                logger.debug(f"SQL injection test error: {e}")

        return details, findings

    async def test_brute_force_protection(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for brute force attack protection"""
        findings = []
        details = {'attempts': 0, 'blocked': False, 'lockout_detected': False}

        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')

        # Attempt multiple failed logins
        for i in range(15):
            details['attempts'] += 1

            try:
                await self.page.fill('input[type="email"], input[name="email"], #email', 'test@example.com')
                await self.page.fill('input[type="password"], input[name="password"], #password', f'wrongpass{i}')
                await self.page.click('button[type="submit"]')
                await self.page.wait_for_timeout(500)

                page_content = await self.page.content()

                # Check for lockout/rate limiting indicators
                lockout_indicators = [
                    'too many attempts', 'account locked', 'try again later',
                    'rate limit', 'temporarily blocked', 'wait', 'captcha'
                ]

                for indicator in lockout_indicators:
                    if indicator.lower() in page_content.lower():
                        details['blocked'] = True
                        details['lockout_detected'] = True
                        break

                if details['blocked']:
                    break

            except Exception as e:
                logger.debug(f"Brute force test error: {e}")

        if not details['blocked'] and details['attempts'] >= 10:
            findings.append(SecurityFinding(
                severity='high',
                category='Authentication',
                title='No Brute Force Protection',
                description=f'Successfully attempted {details["attempts"]} login attempts without being blocked',
                evidence='No rate limiting or account lockout detected',
                recommendation='Implement rate limiting, account lockout, and CAPTCHA after failed attempts',
                cwe_id='CWE-307',
                owasp_category='A07:2021-Identification and Authentication Failures'
            ))

        return details, findings

    async def test_credential_stuffing(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for credential stuffing vulnerabilities"""
        findings = []
        details = {'tested_credentials': 0, 'successful_logins': 0}

        # Common weak credentials to test
        common_credentials = [
            ('admin@example.com', 'admin'),
            ('admin@example.com', 'admin123'),
            ('admin@example.com', 'password'),
            ('admin@example.com', '123456'),
            ('root@example.com', 'root'),
            ('test@example.com', 'test'),
            ('user@example.com', 'user'),
        ]

        for email, password in common_credentials:
            details['tested_credentials'] += 1

            try:
                await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
                await self.page.fill('input[type="email"], input[name="email"], #email', email)
                await self.page.fill('input[type="password"], input[name="password"], #password', password)
                await self.page.click('button[type="submit"]')
                await self.page.wait_for_timeout(1500)

                if '/dashboard' in self.page.url:
                    details['successful_logins'] += 1
                    findings.append(SecurityFinding(
                        severity='high',
                        category='Authentication',
                        title='Weak Credentials Accepted',
                        description=f'Login successful with weak credentials: {email}',
                        evidence=f'Password "{password}" accepted for {email}',
                        recommendation='Enforce strong password policies and check against breached password databases',
                        cwe_id='CWE-521',
                        owasp_category='A07:2021-Identification and Authentication Failures'
                    ))
                    # Logout for next test
                    await self.page.goto(f"{BASE_URL}/login")

            except Exception as e:
                logger.debug(f"Credential stuffing test error: {e}")

        return details, findings

    # =========================================================================
    # AUTHORIZATION ATTACKS
    # =========================================================================

    async def test_idor_vulnerabilities(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for Insecure Direct Object Reference vulnerabilities"""
        findings = []
        details = {'endpoints_tested': 0, 'vulnerable_endpoints': []}

        # Login as student first
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['student']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['student']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # IDOR test endpoints - try to access other users' data
        idor_endpoints = [
            '/api/v1/users/1',
            '/api/v1/users/2',
            '/api/v1/organizations/1',
            '/api/v1/courses/1/students',
            '/api/v1/enrollments/1',
            '/api/v1/analytics/user/1',
            '/api/v1/analytics/user/2',
            '/dashboard/site-admin',
            '/dashboard/org-admin',
            '/admin/users',
            '/admin/organizations',
            '/organization/settings',
        ]

        for endpoint in idor_endpoints:
            details['endpoints_tested'] += 1

            try:
                full_url = f"{BASE_URL}{endpoint}"
                response = await self.page.goto(full_url, wait_until='networkidle')

                # Check if we got unauthorized access
                if response and response.status == 200:
                    page_content = await self.page.content()

                    # Check for sensitive data exposure
                    sensitive_patterns = [
                        r'password', r'secret', r'api[_-]?key', r'token',
                        r'credit[_-]?card', r'ssn', r'social[_-]?security'
                    ]

                    for pattern in sensitive_patterns:
                        if re.search(pattern, page_content, re.IGNORECASE):
                            details['vulnerable_endpoints'].append(endpoint)
                            findings.append(SecurityFinding(
                                severity='high',
                                category='Authorization',
                                title='IDOR - Unauthorized Data Access',
                                description=f'Student role accessed restricted endpoint: {endpoint}',
                                evidence=f'Sensitive pattern "{pattern}" found in response',
                                recommendation='Implement proper authorization checks for all endpoints',
                                cwe_id='CWE-639',
                                owasp_category='A01:2021-Broken Access Control'
                            ))
                            break

                    # Check if admin page accessible to student
                    if 'admin' in endpoint.lower() and 'unauthorized' not in page_content.lower():
                        admin_indicators = ['manage users', 'all organizations', 'system settings']
                        if any(ind in page_content.lower() for ind in admin_indicators):
                            details['vulnerable_endpoints'].append(endpoint)
                            findings.append(SecurityFinding(
                                severity='critical',
                                category='Authorization',
                                title='Privilege Escalation - Admin Access',
                                description=f'Student accessed admin endpoint: {endpoint}',
                                evidence='Admin functionality visible to non-admin user',
                                recommendation='Implement role-based access control (RBAC)',
                                cwe_id='CWE-269',
                                owasp_category='A01:2021-Broken Access Control'
                            ))

            except Exception as e:
                logger.debug(f"IDOR test error for {endpoint}: {e}")

        return details, findings

    async def test_horizontal_privilege_escalation(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for horizontal privilege escalation"""
        findings = []
        details = {'tests_performed': 0, 'escalations_found': 0}

        # Login as student
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['student']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['student']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Try to modify other users' data via URL manipulation
        test_cases = [
            # Try to access another student's progress
            {'url': '/progress?user_id=999', 'action': 'view_other_progress'},
            {'url': '/courses/my-courses?student_id=1', 'action': 'view_other_courses'},
            {'url': '/certificates?user_id=2', 'action': 'view_other_certificates'},
        ]

        for test in test_cases:
            details['tests_performed'] += 1

            try:
                await self.page.goto(f"{BASE_URL}{test['url']}", wait_until='networkidle')
                page_content = await self.page.content()

                # Check if we're seeing another user's data
                if 'unauthorized' not in page_content.lower() and 'forbidden' not in page_content.lower():
                    # Look for data that shouldn't belong to current user
                    if 'other user' in page_content.lower() or 'user 999' in page_content.lower():
                        details['escalations_found'] += 1
                        findings.append(SecurityFinding(
                            severity='high',
                            category='Authorization',
                            title='Horizontal Privilege Escalation',
                            description=f'Accessed other user\'s data via: {test["url"]}',
                            evidence=f'Action: {test["action"]} successful',
                            recommendation='Validate user ownership of resources server-side',
                            cwe_id='CWE-639',
                            owasp_category='A01:2021-Broken Access Control'
                        ))

            except Exception as e:
                logger.debug(f"Horizontal escalation test error: {e}")

        return details, findings

    # =========================================================================
    # INPUT VALIDATION ATTACKS
    # =========================================================================

    async def test_xss_vulnerabilities(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for Cross-Site Scripting vulnerabilities"""
        findings = []
        details = {'payloads_tested': 0, 'vulnerable_fields': []}

        xss_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '"><script>alert("XSS")</script>',
            "'-alert('XSS')-'",
            '<body onload=alert("XSS")>',
            '<iframe src="javascript:alert(\'XSS\')">',
            '{{constructor.constructor("alert(1)")()}}',
            '${alert("XSS")}',
            '<a href="javascript:alert(\'XSS\')">click</a>',
            '<div onmouseover="alert(\'XSS\')">hover</div>',
            '<input onfocus=alert("XSS") autofocus>',
        ]

        # Test registration form
        await self.page.goto(f"{BASE_URL}/register", wait_until='networkidle')

        test_fields = [
            ('input[name="firstName"], #firstName', 'firstName'),
            ('input[name="lastName"], #lastName', 'lastName'),
            ('input[name="email"], #email', 'email'),
            ('input[name="username"], #username', 'username'),
        ]

        for payload in xss_payloads[:5]:  # Test subset for speed
            details['payloads_tested'] += 1

            for selector, field_name in test_fields:
                try:
                    element = await self.page.query_selector(selector)
                    if element:
                        await element.fill(payload)

                except Exception as e:
                    logger.debug(f"XSS field fill error: {e}")

            # Submit and check if payload appears in response
            try:
                await self.page.click('button[type="submit"]')
                await self.page.wait_for_timeout(1000)

                page_content = await self.page.content()

                # Check if XSS payload is reflected without encoding
                if '<script>' in page_content and 'alert' in page_content:
                    details['vulnerable_fields'].append('registration_form')
                    findings.append(SecurityFinding(
                        severity='high',
                        category='XSS',
                        title='Reflected XSS in Registration Form',
                        description='XSS payload reflected without proper encoding',
                        evidence=f'Payload: {payload[:50]}...',
                        recommendation='Implement output encoding and Content Security Policy',
                        cwe_id='CWE-79',
                        owasp_category='A03:2021-Injection'
                    ))
                    break

            except Exception as e:
                logger.debug(f"XSS submission error: {e}")

            await self.page.goto(f"{BASE_URL}/register", wait_until='networkidle')

        # Test search functionality
        await self.page.goto(f"{BASE_URL}/courses", wait_until='networkidle')

        search_input = await self.page.query_selector('input[type="search"], input[name="search"], #search')
        if search_input:
            for payload in xss_payloads[:3]:
                details['payloads_tested'] += 1

                try:
                    await search_input.fill(payload)
                    await self.page.keyboard.press('Enter')
                    await self.page.wait_for_timeout(1000)

                    page_content = await self.page.content()

                    if '<script>' in page_content:
                        details['vulnerable_fields'].append('search')
                        findings.append(SecurityFinding(
                            severity='high',
                            category='XSS',
                            title='Reflected XSS in Search',
                            description='Search functionality vulnerable to XSS',
                            evidence=f'Payload reflected: {payload[:50]}...',
                            recommendation='Sanitize and encode all user input',
                            cwe_id='CWE-79',
                            owasp_category='A03:2021-Injection'
                        ))
                        break

                except Exception as e:
                    logger.debug(f"XSS search test error: {e}")

        return details, findings

    async def test_path_traversal(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for path traversal vulnerabilities"""
        findings = []
        details = {'payloads_tested': 0, 'vulnerable': False}

        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\config\\sam',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%252f..%252f..%252fetc/passwd',
            '/etc/passwd',
            'file:///etc/passwd',
            '....\/....\/....\/etc/passwd',
        ]

        # Test file download/resource endpoints
        test_urls = [
            '/api/v1/files/',
            '/api/v1/resources/',
            '/api/v1/content/',
            '/static/',
            '/uploads/',
        ]

        for base_url in test_urls:
            for payload in traversal_payloads:
                details['payloads_tested'] += 1

                try:
                    full_url = f"{BASE_URL}{base_url}{quote(payload)}"
                    response = await self.page.goto(full_url, wait_until='networkidle')

                    if response:
                        content = await self.page.content()

                        # Check for passwd file content
                        if 'root:' in content or 'daemon:' in content:
                            details['vulnerable'] = True
                            findings.append(SecurityFinding(
                                severity='critical',
                                category='Path Traversal',
                                title='Local File Inclusion',
                                description=f'Path traversal successful at: {base_url}',
                                evidence=f'Payload: {payload}',
                                recommendation='Validate and sanitize file paths, use allowlists',
                                cwe_id='CWE-22',
                                owasp_category='A01:2021-Broken Access Control'
                            ))

                except Exception as e:
                    logger.debug(f"Path traversal test error: {e}")

        return details, findings

    async def test_command_injection(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for command injection vulnerabilities"""
        findings = []
        details = {'payloads_tested': 0, 'vulnerable': False}

        cmd_payloads = [
            '; ls -la',
            '| cat /etc/passwd',
            '`id`',
            '$(whoami)',
            '; ping -c 3 localhost',
            '| sleep 5',
            '\n/bin/cat /etc/passwd',
            '"; ls -la; "',
            "'; ls -la; '",
        ]

        # Test endpoints that might execute commands
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['instructor']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['instructor']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Test content generation or any field that might be processed
        await self.page.goto(f"{BASE_URL}/instructor/content-generator", wait_until='networkidle')

        for payload in cmd_payloads:
            details['payloads_tested'] += 1

            try:
                # Find any text input field
                text_inputs = await self.page.query_selector_all('input[type="text"], textarea')

                for input_el in text_inputs[:2]:
                    start_time = time.time()
                    await input_el.fill(payload)

                # Submit form if exists
                submit_btn = await self.page.query_selector('button[type="submit"]')
                if submit_btn:
                    await submit_btn.click()
                    await self.page.wait_for_timeout(2000)

                    elapsed = time.time() - start_time

                    # Check for time-based injection (sleep command)
                    if 'sleep' in payload and elapsed > 5:
                        details['vulnerable'] = True
                        findings.append(SecurityFinding(
                            severity='critical',
                            category='Command Injection',
                            title='Time-based Command Injection',
                            description='Command injection detected via time delay',
                            evidence=f'Payload "{payload}" caused {elapsed:.1f}s delay',
                            recommendation='Never pass user input to shell commands',
                            cwe_id='CWE-78',
                            owasp_category='A03:2021-Injection'
                        ))

                    page_content = await self.page.content()

                    # Check for command output in response
                    if 'root:' in page_content or 'uid=' in page_content:
                        details['vulnerable'] = True
                        findings.append(SecurityFinding(
                            severity='critical',
                            category='Command Injection',
                            title='OS Command Injection',
                            description='Command output reflected in response',
                            evidence=f'Payload: {payload}',
                            recommendation='Use parameterized APIs, avoid shell commands',
                            cwe_id='CWE-78',
                            owasp_category='A03:2021-Injection'
                        ))

            except Exception as e:
                logger.debug(f"Command injection test error: {e}")

        return details, findings

    # =========================================================================
    # SESSION MANAGEMENT ATTACKS
    # =========================================================================

    async def test_session_fixation(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for session fixation vulnerabilities"""
        findings = []
        details = {'pre_auth_session': None, 'post_auth_session': None, 'vulnerable': False}

        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')

        # Get session before login
        cookies_before = await self.context.cookies()
        session_cookies_before = [c for c in cookies_before if 'session' in c['name'].lower() or 'token' in c['name'].lower()]
        details['pre_auth_session'] = [c['value'][:20] + '...' for c in session_cookies_before]

        # Login
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['student']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['student']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Get session after login
        cookies_after = await self.context.cookies()
        session_cookies_after = [c for c in cookies_after if 'session' in c['name'].lower() or 'token' in c['name'].lower()]
        details['post_auth_session'] = [c['value'][:20] + '...' for c in session_cookies_after]

        # Check if session ID changed after authentication
        if session_cookies_before and session_cookies_after:
            before_values = {c['value'] for c in session_cookies_before}
            after_values = {c['value'] for c in session_cookies_after}

            if before_values & after_values:  # Intersection - same session
                details['vulnerable'] = True
                findings.append(SecurityFinding(
                    severity='high',
                    category='Session Management',
                    title='Session Fixation Vulnerability',
                    description='Session ID not regenerated after authentication',
                    evidence='Same session token before and after login',
                    recommendation='Regenerate session ID after successful authentication',
                    cwe_id='CWE-384',
                    owasp_category='A07:2021-Identification and Authentication Failures'
                ))

        return details, findings

    async def test_session_timeout(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for proper session timeout"""
        findings = []
        details = {'session_persists': False, 'timeout_detected': False}

        # Login and note session
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['student']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['student']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Check if logged in
        initial_url = self.page.url
        if '/dashboard' in initial_url:
            # Wait a short time (can't wait for real timeout in test)
            await self.page.wait_for_timeout(5000)

            # Try to access protected resource
            await self.page.goto(f"{BASE_URL}/dashboard", wait_until='networkidle')

            current_url = self.page.url
            if '/dashboard' in current_url:
                details['session_persists'] = True
                # Note: In real test, would wait longer to check timeout

        return details, findings

    async def test_jwt_vulnerabilities(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for JWT token vulnerabilities"""
        findings = []
        details = {'jwt_found': False, 'algorithm_none': False, 'weak_secret': False}

        # Login to get JWT
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['student']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['student']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Check cookies and localStorage for JWT
        cookies = await self.context.cookies()
        jwt_tokens = []

        for cookie in cookies:
            if 'token' in cookie['name'].lower() or 'jwt' in cookie['name'].lower():
                jwt_tokens.append(cookie['value'])

        # Check localStorage
        local_storage_token = await self.page.evaluate('''() => {
            return localStorage.getItem('token') ||
                   localStorage.getItem('authToken') ||
                   localStorage.getItem('accessToken');
        }''')

        if local_storage_token:
            jwt_tokens.append(local_storage_token)

        for token in jwt_tokens:
            if token and '.' in token:
                details['jwt_found'] = True
                parts = token.split('.')

                if len(parts) >= 2:
                    try:
                        import base64
                        # Decode header
                        header = parts[0] + '=' * (4 - len(parts[0]) % 4)
                        header_decoded = base64.urlsafe_b64decode(header).decode('utf-8')
                        header_json = json.loads(header_decoded)

                        # Check for 'none' algorithm
                        if header_json.get('alg', '').lower() == 'none':
                            details['algorithm_none'] = True
                            findings.append(SecurityFinding(
                                severity='critical',
                                category='JWT',
                                title='JWT None Algorithm Accepted',
                                description='JWT accepts "none" algorithm',
                                evidence=f'Header: {header_decoded}',
                                recommendation='Explicitly validate algorithm and reject "none"',
                                cwe_id='CWE-347',
                                owasp_category='A02:2021-Cryptographic Failures'
                            ))

                        # Check for weak algorithm
                        if header_json.get('alg') == 'HS256':
                            # Note: HS256 is fine, but check for weak secrets
                            pass

                    except Exception as e:
                        logger.debug(f"JWT decode error: {e}")

        return details, findings

    # =========================================================================
    # API SECURITY ATTACKS
    # =========================================================================

    async def test_api_rate_limiting(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for API rate limiting"""
        findings = []
        details = {'requests_sent': 0, 'rate_limited': False}

        # Login first
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['student']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['student']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Rapid API requests
        for i in range(50):
            details['requests_sent'] += 1

            try:
                response = await self.page.goto(f"{BASE_URL}/api/v1/courses", wait_until='networkidle')

                if response and response.status == 429:
                    details['rate_limited'] = True
                    break

            except Exception as e:
                logger.debug(f"Rate limit test error: {e}")

        if not details['rate_limited'] and details['requests_sent'] >= 50:
            findings.append(SecurityFinding(
                severity='medium',
                category='API Security',
                title='No API Rate Limiting',
                description=f'Sent {details["requests_sent"]} requests without being rate limited',
                evidence='No 429 response received',
                recommendation='Implement rate limiting on API endpoints',
                cwe_id='CWE-770',
                owasp_category='A04:2021-Insecure Design'
            ))

        return details, findings

    async def test_sensitive_data_exposure(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for sensitive data exposure in API responses"""
        findings = []
        details = {'endpoints_checked': 0, 'exposed_data': []}

        sensitive_patterns = {
            'password': r'password["\s:]+["\'][^"\']+["\']',
            'api_key': r'api[_-]?key["\s:]+["\'][^"\']+["\']',
            'secret': r'secret["\s:]+["\'][^"\']+["\']',
            'token': r'(access|refresh|auth)[_-]?token["\s:]+["\'][^"\']+["\']',
            'credit_card': r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b',
            'ssn': r'\b\d{3}-\d{2}-\d{4}\b',
            'private_key': r'-----BEGIN (RSA )?PRIVATE KEY-----',
        }

        # Login
        await self.page.goto(f"{BASE_URL}/login", wait_until='networkidle')
        await self.page.fill('input[type="email"], input[name="email"], #email', VALID_CREDENTIALS['org_admin']['email'])
        await self.page.fill('input[type="password"], input[name="password"], #password', VALID_CREDENTIALS['org_admin']['password'])
        await self.page.click('button[type="submit"]')
        await self.page.wait_for_timeout(2000)

        # Check various API endpoints
        endpoints = [
            '/api/v1/users/me',
            '/api/v1/organizations/me',
            '/api/v1/courses',
            '/api/v1/analytics/me',
        ]

        for endpoint in endpoints:
            details['endpoints_checked'] += 1

            try:
                response = await self.page.goto(f"{BASE_URL}{endpoint}", wait_until='networkidle')

                if response:
                    content = await self.page.content()

                    for data_type, pattern in sensitive_patterns.items():
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            details['exposed_data'].append({
                                'endpoint': endpoint,
                                'data_type': data_type,
                                'match_count': len(matches)
                            })
                            findings.append(SecurityFinding(
                                severity='high' if data_type in ['password', 'private_key', 'credit_card'] else 'medium',
                                category='Data Exposure',
                                title=f'Sensitive Data Exposed: {data_type}',
                                description=f'{data_type} found in API response at {endpoint}',
                                evidence=f'Pattern matches: {len(matches)}',
                                recommendation='Remove sensitive data from API responses, use data masking',
                                cwe_id='CWE-200',
                                owasp_category='A02:2021-Cryptographic Failures'
                            ))

            except Exception as e:
                logger.debug(f"Data exposure test error: {e}")

        return details, findings

    async def test_cors_misconfiguration(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for CORS misconfigurations"""
        findings = []
        details = {'cors_headers': {}, 'vulnerable': False}

        try:
            # Make request with Origin header
            response = await self.page.goto(f"{BASE_URL}/api/v1/health", wait_until='networkidle')

            if response:
                headers = response.headers

                cors_headers = {
                    'access-control-allow-origin': headers.get('access-control-allow-origin'),
                    'access-control-allow-credentials': headers.get('access-control-allow-credentials'),
                    'access-control-allow-methods': headers.get('access-control-allow-methods'),
                }
                details['cors_headers'] = cors_headers

                # Check for wildcard with credentials
                if cors_headers.get('access-control-allow-origin') == '*':
                    if cors_headers.get('access-control-allow-credentials') == 'true':
                        details['vulnerable'] = True
                        findings.append(SecurityFinding(
                            severity='high',
                            category='CORS',
                            title='CORS Wildcard with Credentials',
                            description='CORS allows any origin with credentials',
                            evidence='Access-Control-Allow-Origin: * with credentials: true',
                            recommendation='Specify allowed origins explicitly',
                            cwe_id='CWE-942',
                            owasp_category='A01:2021-Broken Access Control'
                        ))
                    else:
                        findings.append(SecurityFinding(
                            severity='medium',
                            category='CORS',
                            title='CORS Wildcard Origin',
                            description='CORS allows any origin',
                            evidence='Access-Control-Allow-Origin: *',
                            recommendation='Restrict allowed origins to trusted domains',
                            cwe_id='CWE-942',
                            owasp_category='A01:2021-Broken Access Control'
                        ))

        except Exception as e:
            logger.debug(f"CORS test error: {e}")

        return details, findings

    # =========================================================================
    # SECURITY HEADER CHECKS
    # =========================================================================

    async def test_security_headers(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for missing security headers"""
        findings = []
        details = {'headers_present': [], 'headers_missing': []}

        required_headers = {
            'strict-transport-security': 'HSTS',
            'x-content-type-options': 'X-Content-Type-Options',
            'x-frame-options': 'X-Frame-Options',
            'x-xss-protection': 'X-XSS-Protection',
            'content-security-policy': 'CSP',
            'referrer-policy': 'Referrer-Policy',
            'permissions-policy': 'Permissions-Policy',
        }

        try:
            response = await self.page.goto(BASE_URL, wait_until='networkidle')

            if response:
                headers = response.headers

                for header, name in required_headers.items():
                    if header in headers:
                        details['headers_present'].append(name)
                    else:
                        details['headers_missing'].append(name)

                        severity = 'high' if header in ['strict-transport-security', 'content-security-policy'] else 'medium'
                        findings.append(SecurityFinding(
                            severity=severity,
                            category='Security Headers',
                            title=f'Missing {name} Header',
                            description=f'Security header {header} is not set',
                            evidence=f'Header not found in response',
                            recommendation=f'Add {header} header to all responses',
                            cwe_id='CWE-693',
                            owasp_category='A05:2021-Security Misconfiguration'
                        ))

        except Exception as e:
            logger.debug(f"Security headers test error: {e}")

        return details, findings

    async def test_information_disclosure(self) -> Tuple[Dict, List[SecurityFinding]]:
        """Test for information disclosure in headers and error pages"""
        findings = []
        details = {'server_info': None, 'framework_info': None, 'stack_traces': False}

        try:
            response = await self.page.goto(BASE_URL, wait_until='networkidle')

            if response:
                headers = response.headers

                # Check server header
                server = headers.get('server')
                if server:
                    details['server_info'] = server
                    if any(v in server.lower() for v in ['nginx/', 'apache/', 'iis/']):
                        findings.append(SecurityFinding(
                            severity='low',
                            category='Information Disclosure',
                            title='Server Version Disclosed',
                            description=f'Server header reveals version: {server}',
                            evidence=f'Server: {server}',
                            recommendation='Remove or genericize Server header',
                            cwe_id='CWE-200',
                            owasp_category='A05:2021-Security Misconfiguration'
                        ))

                # Check X-Powered-By
                powered_by = headers.get('x-powered-by')
                if powered_by:
                    details['framework_info'] = powered_by
                    findings.append(SecurityFinding(
                        severity='low',
                        category='Information Disclosure',
                        title='Framework Version Disclosed',
                        description=f'X-Powered-By header reveals: {powered_by}',
                        evidence=f'X-Powered-By: {powered_by}',
                        recommendation='Remove X-Powered-By header',
                        cwe_id='CWE-200',
                        owasp_category='A05:2021-Security Misconfiguration'
                    ))

            # Test error page for stack traces
            response = await self.page.goto(f"{BASE_URL}/nonexistent-page-12345", wait_until='networkidle')
            content = await self.page.content()

            stack_trace_indicators = [
                'traceback', 'stack trace', 'exception', 'at line',
                'file "/', 'in <module>', 'raise ', 'error in'
            ]

            for indicator in stack_trace_indicators:
                if indicator.lower() in content.lower():
                    details['stack_traces'] = True
                    findings.append(SecurityFinding(
                        severity='medium',
                        category='Information Disclosure',
                        title='Stack Trace Exposed',
                        description='Error page reveals stack trace/debug information',
                        evidence=f'Found indicator: {indicator}',
                        recommendation='Disable debug mode, use generic error pages',
                        cwe_id='CWE-209',
                        owasp_category='A05:2021-Security Misconfiguration'
                    ))
                    break

        except Exception as e:
            logger.debug(f"Information disclosure test error: {e}")

        return details, findings

    # =========================================================================
    # MAIN TEST RUNNER
    # =========================================================================

    async def run_all_tests(self):
        """Run all security tests"""

        # Authentication attacks
        await self.run_test("sql_injection_login", "authentication", self.test_sql_injection_login)
        await self.run_test("brute_force_protection", "authentication", self.test_brute_force_protection)
        await self.run_test("credential_stuffing", "authentication", self.test_credential_stuffing)

        # Authorization attacks
        await self.run_test("idor_vulnerabilities", "authorization", self.test_idor_vulnerabilities)
        await self.run_test("horizontal_privilege_escalation", "authorization", self.test_horizontal_privilege_escalation)

        # Input validation attacks
        await self.run_test("xss_vulnerabilities", "input_validation", self.test_xss_vulnerabilities)
        await self.run_test("path_traversal", "input_validation", self.test_path_traversal)
        await self.run_test("command_injection", "input_validation", self.test_command_injection)

        # Session management
        await self.run_test("session_fixation", "session", self.test_session_fixation)
        await self.run_test("session_timeout", "session", self.test_session_timeout)
        await self.run_test("jwt_vulnerabilities", "session", self.test_jwt_vulnerabilities)

        # API security
        await self.run_test("api_rate_limiting", "api", self.test_api_rate_limiting)
        await self.run_test("sensitive_data_exposure", "api", self.test_sensitive_data_exposure)
        await self.run_test("cors_misconfiguration", "api", self.test_cors_misconfiguration)

        # Security headers
        await self.run_test("security_headers", "headers", self.test_security_headers)
        await self.run_test("information_disclosure", "headers", self.test_information_disclosure)

    def generate_report(self) -> str:
        """Generate security test report"""
        report = []
        report.append("=" * 70)
        report.append("SECURITY PENETRATION TEST REPORT")
        report.append("Course Creator Platform")
        report.append("=" * 70)
        report.append(f"Test Run ID: {self.test_run_id}")
        report.append(f"Date: {datetime.now().isoformat()}")
        report.append(f"Target: {BASE_URL}")
        report.append("")

        # Summary
        total_tests = len(self.results)
        passed_tests = sum(1 for r in self.results if r.passed)
        failed_tests = total_tests - passed_tests

        critical_findings = [f for f in self.findings if f.severity == 'critical']
        high_findings = [f for f in self.findings if f.severity == 'high']
        medium_findings = [f for f in self.findings if f.severity == 'medium']
        low_findings = [f for f in self.findings if f.severity == 'low']

        report.append("EXECUTIVE SUMMARY")
        report.append("-" * 70)
        report.append(f"Tests Executed: {total_tests}")
        report.append(f"Tests Passed (No Critical/High Issues): {passed_tests}")
        report.append(f"Tests Failed (Critical/High Issues Found): {failed_tests}")
        report.append("")
        report.append("VULNERABILITY SUMMARY")
        report.append(f"  ðŸ”´ Critical: {len(critical_findings)}")
        report.append(f"  ðŸŸ  High: {len(high_findings)}")
        report.append(f"  ðŸŸ¡ Medium: {len(medium_findings)}")
        report.append(f"  ðŸŸ¢ Low: {len(low_findings)}")
        report.append(f"  Total Findings: {len(self.findings)}")
        report.append("")

        # Risk Assessment
        if critical_findings:
            risk_level = "CRITICAL"
            risk_color = "ðŸ”´"
        elif high_findings:
            risk_level = "HIGH"
            risk_color = "ðŸŸ "
        elif medium_findings:
            risk_level = "MEDIUM"
            risk_color = "ðŸŸ¡"
        elif low_findings:
            risk_level = "LOW"
            risk_color = "ðŸŸ¢"
        else:
            risk_level = "MINIMAL"
            risk_color = "âœ…"

        report.append(f"OVERALL RISK LEVEL: {risk_color} {risk_level}")
        report.append("")

        # Detailed Findings
        if self.findings:
            report.append("=" * 70)
            report.append("DETAILED FINDINGS")
            report.append("=" * 70)

            for severity in ['critical', 'high', 'medium', 'low']:
                severity_findings = [f for f in self.findings if f.severity == severity]
                if severity_findings:
                    report.append("")
                    report.append(f"--- {severity.upper()} SEVERITY ({len(severity_findings)}) ---")

                    for i, finding in enumerate(severity_findings, 1):
                        report.append("")
                        report.append(f"[{severity.upper()}-{i}] {finding.title}")
                        report.append(f"  Category: {finding.category}")
                        if finding.cwe_id:
                            report.append(f"  CWE: {finding.cwe_id}")
                        if finding.owasp_category:
                            report.append(f"  OWASP: {finding.owasp_category}")
                        report.append(f"  Description: {finding.description}")
                        report.append(f"  Evidence: {finding.evidence}")
                        report.append(f"  Recommendation: {finding.recommendation}")

        # Test Results by Category
        report.append("")
        report.append("=" * 70)
        report.append("TEST RESULTS BY CATEGORY")
        report.append("=" * 70)

        categories = {}
        for result in self.results:
            if result.category not in categories:
                categories[result.category] = []
            categories[result.category].append(result)

        for category, results in categories.items():
            passed = sum(1 for r in results if r.passed)
            report.append(f"\n{category.upper()}:")
            for result in results:
                status = "âœ… SECURE" if result.passed else "ðŸ”´ VULNERABLE"
                report.append(f"  {status} {result.test_name} ({result.duration_ms}ms)")

        report.append("")
        report.append("=" * 70)
        report.append("END OF REPORT")
        report.append("=" * 70)

        return "\n".join(report)

    def save_results(self):
        """Save results to files"""
        # Save JSON results
        results_data = {
            'test_run_id': self.test_run_id,
            'timestamp': datetime.now().isoformat(),
            'target': BASE_URL,
            'summary': {
                'total_tests': len(self.results),
                'passed': sum(1 for r in self.results if r.passed),
                'failed': sum(1 for r in self.results if not r.passed),
                'total_findings': len(self.findings),
                'critical': len([f for f in self.findings if f.severity == 'critical']),
                'high': len([f for f in self.findings if f.severity == 'high']),
                'medium': len([f for f in self.findings if f.severity == 'medium']),
                'low': len([f for f in self.findings if f.severity == 'low']),
            },
            'findings': [
                {
                    'severity': f.severity,
                    'category': f.category,
                    'title': f.title,
                    'description': f.description,
                    'evidence': f.evidence,
                    'recommendation': f.recommendation,
                    'cwe_id': f.cwe_id,
                    'owasp_category': f.owasp_category,
                }
                for f in self.findings
            ],
            'test_results': [
                {
                    'name': r.test_name,
                    'category': r.category,
                    'passed': r.passed,
                    'duration_ms': r.duration_ms,
                    'details': r.details,
                }
                for r in self.results
            ]
        }

        json_path = OUTPUT_DIR / f'security_report_{self.test_run_id}.json'
        with open(json_path, 'w') as f:
            json.dump(results_data, f, indent=2)

        # Save text report
        report = self.generate_report()
        report_path = OUTPUT_DIR / f'security_report_{self.test_run_id}.txt'
        with open(report_path, 'w') as f:
            f.write(report)

        logger.info(f"Results saved to: {OUTPUT_DIR}")

        return report


async def main():
    """Main entry point"""
    tester = SecurityPenTester()

    try:
        await tester.setup()
        await tester.run_all_tests()
        report = tester.save_results()
        print(report)

    finally:
        await tester.teardown()


if __name__ == '__main__':
    asyncio.run(main())
